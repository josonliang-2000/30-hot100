> 前置知识点
>
> 1. 一般默认限时1s ≈ 10^8语句频度， 即数据规模`n < 10^4`情况下，才可以使用`O(n^2)`的算法；
> 2. 笔试一般空间限制 64MB / 128MB， hot100而言基本不需要考虑空间限制；

## 哈希

### [1.两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 ：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

> 分析
>
> 1. 数组中同一个元素在答案里不能重复出现 --> 每个元素只能用一次
> 2. 数据保证只有一组答案 --> 不存在重复元素
> 3. 数据保证数组元素个数大于等于2 --> 无需特判

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> mp;

        for (int i = 0; i < n; ++i) {
            int key = target - nums[i];
            if (mp.find(key) != mp.end()) {
                return {mp[key], i};
            }
            mp.emplace(nums[i], i);
        }

        return {};
    }
};
```

- 时间复杂度：`O(n)`
- 空间负责度：`O(n)`

## 栈

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

> 分析
>
> 1. 不能二重循环`O(n^2)`
>
> 2. 能勾勒的最大矩形，其顶部一定是某个柱子的顶部。
>
>    反证法：假设存在一个最大矩形，其顶部不是任何一个柱子的顶部。这说明矩形还能往上再增大，与最大相矛盾。
>
> 3. 由2可知，枚举heights，并在`O(1)`复杂度内计算出，以`height[i]`为顶部时可以获得的最大矩形`rect[i]`，
>
>    最终取最大的`rect[i] (0 <= i < n )` 即为答案。
>
>    - 如何`O(1)`复杂度计算出以`height[i]`为顶部时可以获得的最大矩形：当高度为`height[i]`，只需求维持该高度的最大宽度，即分别获取`i`左边比height[i]小的最大下标` left[i]`、`i`右边比`height[i]`小的最小下标`right[i]`，最大宽度= k - j - 1。
>     - 对于求`right`，相当于从`i`往右走，找到最近的比`height[i]`小的下标，故从左开始遍历，使用单调增栈；对于所求`left`，则反过来从右开始遍历即可。（为啥使用单调增栈？ —— 以求right为例，即遇到比当前大的进栈，遇到比当前小的出栈，出栈时收集k）
>    

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        // left[i]、right[i]分别表示左、右两边最靠近的比height[i]小的元素下标
        vector<int> left(n, -1), right(n, n); // 遵循开区间
        vector<int> st; // 单调增栈

        // 先求right
        for (int i = 0; i < n; i++) {
            int x = heights[i];
            // 出栈
            while (!st.empty() && x < heights[st.back()]) {
                right[st.back()] = i; st.pop_back();
            }
            // 入栈
            st.push_back(i);
        }

        st.clear();
        // 求left
        for (int i = n - 1; i >= 0; i--) {
            int x = heights[i];
            while (!st.empty() && x < heights[st.back()]) {
                left[st.back()] = i; st.pop_back();
            }
            st.push_back(i);
        }

        // 枚举柱子
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int s = heights[i] * (right[i] - left[i] - 1);
            ans = max(ans, s);
        }

        return ans;
    }
};
```

- 时间复杂度：`O(n)`，求left和right 2n + 枚举 n = 3n
- 空间复杂度：`O(n)`

## 堆

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

>分析
>需要考虑重复元素，而不是去重后的第k大 。
>
>法一：快速选择
>即快排思想。每一轮快速选择后，将寻找的范围近似减半，即 `n + n/2 + n/4 + ... = n(1 + 1/2 + 1/4 + ...) --> 2n`， 时间复杂度为`O(n)`。
>
>法二：桶排序
>数据范围` 2 * 10^4 * sizeof(int) = 8 * 10^4 B ≈ 80MB`，勉强可以空间换时间。开一个80MB大小的数组`b`，`b[i]`则表示值为`i`的元素个数。从`b[n - 1]`开始往前收集，收集到的第k个数即是第k大。

法一：快速选择

```c++
class Solution {
public:
    #define NaN (1e5 + 1) 
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < k) return NaN; // k异常

        auto qsort = [&](auto&& self, int left, int right, int k) ->int {
            if (left == right) return nums[left];

            // 快排模版一：选择ceil(n / 2)位置为枢纽x
            int x = nums[left + right + 1 >> 1];
            int i = left - 1, j = right + 1;
            while (i < j) {
                while (nums[++i] < x);
                while (nums[--j] > x);
                if (i < j) swap(nums[i], nums[j]);
            }
            // 完成此轮，i总是右半部分首位
            int rnum = right - i + 1; // 右半部分元素个数
            if (k <= rnum) return self(self, i, right, k); // 继续在右边找第k大
            else return self(self, left, i - 1, k - rnum); // 在左边找第 k - rnum 大即可

            // 快排模版二：选择floor(n / 2)位置为枢纽x
            // int x = nums[left + right >> 1];
            // int i = left - 1, j = right + 1;
            // while (i < j) {
            //     while (nums[++i] < x);
            //     while (nums[--j] > x);
            //     if (i < j) swap(nums[i], nums[j]);
            // }
            // // 完成一轮， j总是在左半部分尾
            // int rnum = right - j;
            // if (k <= rnum) return self(self, j + 1, right, k);
            // else return self(self, left, j, k - rnum);
        };

        return qsort(qsort, 0, n - 1, k);
    }
};
```

- 时间复杂度`O(n)`
- 空间复杂度`O(n)`，递归栈空间

这是闫总推荐的快排模版，我们熟悉快排思想即可，手撕还得用前人总结下来的模板，规避了重复值等特殊情况会带来的死循环。
模板要点：

1. 枢纽选择。无脑选择中间位置（`l + r + 1 >> 1`或者`l + r >> 1`）的值，这是最简单避免单调性的方法，写题够用；
2. `l + r + 1 >> 1`时，下一层递归参数用`i`,
   `l + r >> 1`时，下一层递归参数用`j`。

法二：桶排序

```c++
class Solution {
public:
    #define N 20001
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> bucket(N);

        // 将 -10000 ~ 10000 映射到 0 ~ 20000
        for (int num : nums) {
            bucket[num + 10000]++;
        }

        for (int i = 20000; i >= 0; --i) {
            k -= bucket[i];
            if (k <= 0) return i - 10000;
        }

        return N; // k异常
    }
};
```

- 时间复杂度：`O(数据范围)`
- 空间复杂度：`O(数据范围)`

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

