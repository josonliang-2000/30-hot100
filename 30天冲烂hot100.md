> 前置知识点
>
> 1. 一般默认限时1s ≈ 10^8语句频度， 即数据规模`n < 10^4`情况下，才可以使用`O(n^2)`的算法；
> 2. 笔试一般空间限制 64MB / 128MB， hot100而言基本不需要考虑空间限制；

## 哈希

### [1.两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 ：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

> 分析
>
> 1. 数组中同一个元素在答案里不能重复出现 --> 每个元素只能用一次
> 2. 数据保证只有一组答案 --> 不存在重复元素
> 3. 数据保证数组元素个数大于等于2 --> 无需特判

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> mp;

        for (int i = 0; i < n; ++i) {
            int key = target - nums[i];
            if (mp.find(key) != mp.end()) {
                return {mp[key], i};
            }
            mp.emplace(nums[i], i);
        }

        return {};
    }
};
```

- 时间复杂度：`O(n)`
- 空间负责度：`O(n)`

## 栈

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

> 分析
>
> 1. 不能二重循环`O(n^2)`
>
> 2. 能勾勒的最大矩形，其顶部一定是某个柱子的顶部。
>
>    反证法：假设存在一个最大矩形，其顶部不是任何一个柱子的顶部。这说明矩形还能往上再增大，与最大相矛盾。
>
> 3. 由2可知，枚举heights，并在`O(1)`复杂度内计算出，以`height[i]`为顶部时可以获得的最大矩形`rect[i]`，
>
>    最终取最大的`rect[i] (0 <= i < n )` 即为答案。
>
>    - 如何`O(1)`复杂度计算出以`height[i]`为顶部时可以获得的最大矩形：当高度为`height[i]`，只需求维持该高度的最大宽度，假设已知`i`左边比height[i]小的最大下标` left[i]`、`i`右边比`height[i]`小的最小下标`right[i]`，则最大宽度= `right[i] - left[i] - 1`。
>
>    - rleft和right都可以利用单调栈在O(n)遍历中求得。对于求`right`，相当于从`i`往右走，找到最近的比`height[i]`小的下标，故从左开始遍历，使用单调增栈；对于所求`left`，则反过来从右开始遍历即可。（为啥使用单调增栈？ —— 以求right为例，即遇到比当前大的进栈，遇到比当前小的出栈，出栈时收集k）
>    

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        // left[i]、right[i]分别表示左、右两边最靠近的比height[i]小的元素下标
        vector<int> left(n, -1), right(n, n); // 遵循开区间
        vector<int> st; // 单调增栈

        // 先求right
        for (int i = 0; i < n; i++) {
            int x = heights[i];
            // 出栈
            while (!st.empty() && x < heights[st.back()]) {
                right[st.back()] = i; st.pop_back();
            }
            // 入栈
            st.push_back(i);
        }

        st.clear();
        // 求left
        for (int i = n - 1; i >= 0; i--) {
            int x = heights[i];
            while (!st.empty() && x < heights[st.back()]) {
                left[st.back()] = i; st.pop_back();
            }
            st.push_back(i);
        }

        // 枚举柱子
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int s = heights[i] * (right[i] - left[i] - 1);
            ans = max(ans, s);
        }

        return ans;
    }
};
```

- 时间复杂度：`O(n)`，求left和right 2n + 枚举 n = 3n
- 空间复杂度：`O(n)`

## 堆

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

>分析
>需要考虑重复元素，而不是去重后的第k大 。
>
>法一：快速选择
>即快排思想。每一轮快速选择后，将寻找的范围近似减半，即 `n + n/2 + n/4 + ... = n(1 + 1/2 + 1/4 + ...) --> 2n`， 时间复杂度为`O(n)`。
>
>法二：桶排序
>数据范围` 2 * 10^4 * sizeof(int) = 8 * 10^4 B ≈ 80MB`，勉强可以空间换时间。开一个80MB大小的数组`b`，`b[i]`则表示值为`i`的元素个数。从`b[n - 1]`开始往前收集，收集到的第k个数即是第k大。

法一：快速选择

```c++
class Solution {
public:
    #define NaN (1e5 + 1) 
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < k) return NaN; // k异常

        auto qsort = [&](auto&& self, int left, int right, int k) ->int {
            if (left == right) return nums[left];

            // 快排模版一：选择ceil(n / 2)位置为枢纽x
            int x = nums[left + right + 1 >> 1];
            int i = left - 1, j = right + 1;
            while (i < j) {
                while (nums[++i] < x);
                while (nums[--j] > x);
                if (i < j) swap(nums[i], nums[j]);
            }
            // 完成此轮，i总是右半部分首位
            int rnum = right - i + 1; // 右半部分元素个数
            if (k <= rnum) return self(self, i, right, k); // 继续在右边找第k大
            else return self(self, left, i - 1, k - rnum); // 在左边找第 k - rnum 大即可

            // 快排模版二：选择floor(n / 2)位置为枢纽x
            // int x = nums[left + right >> 1];
            // int i = left - 1, j = right + 1;
            // while (i < j) {
            //     while (nums[++i] < x);
            //     while (nums[--j] > x);
            //     if (i < j) swap(nums[i], nums[j]);
            // }
            // // 完成一轮， j总是在左半部分尾
            // int rnum = right - j;
            // if (k <= rnum) return self(self, j + 1, right, k);
            // else return self(self, left, j, k - rnum);
        };

        return qsort(qsort, 0, n - 1, k);
    }
};
```

- 时间复杂度`O(n)`
- 空间复杂度`O(n)`，递归栈空间

这是闫总推荐的快排模版，我们熟悉快排思想即可，手撕还得用前人总结下来的模板，规避了重复值等特殊情况会带来的死循环。
模板要点：

1. 枢纽选择。无脑选择中间位置（`l + r + 1 >> 1`或者`l + r >> 1`）的值，这是最简单避免单调性的方法，写题够用；
2. `l + r + 1 >> 1`时，下一层递归参数用`i`,
   `l + r >> 1`时，下一层递归参数用`j`。

法二：桶排序

```c++
class Solution {
public:
    #define N 20001
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> bucket(N);

        // 将 -10000 ~ 10000 映射到 0 ~ 20000
        for (int num : nums) {
            bucket[num + 10000]++;
        }

        for (int i = 20000; i >= 0; --i) {
            k -= bucket[i];
            if (k <= 0) return i - 10000;
        }

        return N; // k异常
    }
};
```

- 时间复杂度：`O(数据范围)`
- 空间复杂度：`O(数据范围)`

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

>分析
>
>前k大使用小顶堆，前k小使用大顶堆。
>边遍历边入堆，当堆的size > k时，pop一下。这样的遍历方式使得当下的堆里始终是目前最大/小的k个值。

```c++
class Solution {
public:
    struct MyCompre {
        // 若用class记得声明为public
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs)const {
            // 小顶堆，其实现是从底向上 层层比较，rhs可以看成较上层
            return lhs.second > rhs.second; 
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        int n = nums.size();
        unordered_map<int, int> mp;        

        for (int num : nums) {
            mp[num]++;
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, MyCompre> que;
        for (const auto& p : mp) {
            que.emplace(p);
            if (que.size() > k) {
                que.pop();
            }
        }

        // 这里按大到小收集答案
        vector<int> res(k);
        for (int i = k - 1; i >= 0; --i) {
            res[i] = que.top().first; que.pop();
        }
        return res;
    }
};
```

- 时间复杂度：`Onlog(k)`，每次入堆`Olog(k)`
- 空间复杂度：`O(n)`

### [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() `初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

**示例 1：**

```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

**提示:**

- `-105 <= num <= 105`
- 在调用 `findMedian` 之前，数据结构中至少有一个元素
- 最多 `5 * 104` 次调用 `addNum` 和 `findMedian`

> 分析
>
> 要`O(nlogn)`以上。
> 考虑用大根堆`lq`存前半段，小根堆`rq`存后半段，这样两个堆顶就是中间的值。
>
> - addNum时，优先放大根堆`lq`，保证有偶数个数时，两个堆size一样；奇数个时，左边的大根堆`lq`多一个
> - findMedian时，若两个堆size一样，则取两个堆顶出来求平均值，否则，直接返回大根堆`lq`的顶。

```c++
class MedianFinder {
    priority_queue<int> lq; // 大根堆
    priority_queue<int, vector<int>, greater<int>> rq; // 小根堆
public:
    MedianFinder() {

    }
    void addNum(int num) {
        if (lq.size() == rq.size()) { // 元素个数一样：优先放lq  
            if (lq.empty() || num <= rq.top()) {
                lq.push(num);
            } else {
                lq.push(rq.top()); rq.pop();
                rq.push(num);
            }
            
        } else { // lq多一个元素: 搞成一样 
            if (num >= lq.top()) {
                rq.push(num);
            } else {
                rq.push(lq.top()); lq.pop();
                lq.push(num);
            }
        }
    }
    double findMedian() {
        if (lq.empty()) return -1e6;

        double ans;
        if (lq.size() == rq.size()) {
            ans = (lq.top() + rq.top()) / 2.0;
        } else {
            ans = lq.top();
        }

        return ans;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

