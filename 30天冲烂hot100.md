> 前置知识点
>
> 1. 一般默认限时1s ≈ 10^8语句频度， 即数据规模`n < 10^4`情况下，才可以使用`O(n^2)`的算法；
> 2. 笔试一般空间限制 64MB / 128MB， hot100而言基本不需要考虑空间限制；

## 哈希

### [1.两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 ：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

> 分析
>
> 1. 数组中同一个元素在答案里不能重复出现 --> 每个元素只能用一次
> 2. 数据保证只有一组答案 --> 不存在重复元素
> 3. 数据保证数组元素个数大于等于2 --> 无需特判

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> mp;

        for (int i = 0; i < n; ++i) {
            int key = target - nums[i];
            if (mp.find(key) != mp.end()) {
                return {mp[key], i};
            }
            mp.emplace(nums[i], i);
        }

        return {};
    }
};
```

- 时间复杂度：`O(n)`
- 空间负责度：`O(n)`

## 栈

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

> 分析
>
> 1. 不能二重循环`O(n^2)`
>
> 2. 能勾勒的最大矩形，其顶部一定是某个柱子的顶部。
>
>    反证法：假设存在一个最大矩形，其顶部不是任何一个柱子的顶部。这说明矩形还能往上再增大，与最大相矛盾。
>
> 3. 由2可知，枚举heights，并在`O(1)`复杂度内计算出，以`height[i]`为顶部时可以获得的最大矩形`rect[i]`，
>
>    最终取最大的`rect[i] (0 <= i < n )` 即为答案。
>
>    - 如何`O(1)`复杂度计算出以`height[i]`为顶部时可以获得的最大矩形：当高度为`height[i]`，只需求维持该高度的最大宽度，假设已知`i`左边比height[i]小的最大下标` left[i]`、`i`右边比`height[i]`小的最小下标`right[i]`，则最大宽度= `right[i] - left[i] - 1`。
>
>    - rleft和right都可以利用单调栈在O(n)遍历中求得。对于求`right`，相当于从`i`往右走，找到最近的比`height[i]`小的下标，故从左开始遍历，使用单调增栈操作；对于所求`left`，则反过来从右开始遍历即可。（为啥使用单调增栈？ —— 以求right为例，即遇到比当前大的进栈，遇到比当前小的出栈，出栈时收集k）
>    

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        // left[i]、right[i]分别表示左、右两边最靠近的比height[i]小的元素下标
        vector<int> left(n, -1), right(n, n); // 遵循开区间
        vector<int> st; // 单调增栈

        // 先求right
        for (int i = 0; i < n; i++) {
            int x = heights[i];
            // 出栈
            while (!st.empty() && x < heights[st.back()]) {
                right[st.back()] = i; st.pop_back();
            }
            // 入栈
            st.push_back(i);
        }

        st.clear();
        // 求left
        for (int i = n - 1; i >= 0; i--) {
            int x = heights[i];
            while (!st.empty() && x < heights[st.back()]) {
                left[st.back()] = i; st.pop_back();
            }
            st.push_back(i);
        }

        // 枚举柱子
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int s = heights[i] * (right[i] - left[i] - 1);
            ans = max(ans, s);
        }

        return ans;
    }
};
```

- 时间复杂度：`O(n)`，求left和right 2n + 枚举 n = 3n
- 空间复杂度：`O(n)`

## 堆

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

>分析
>需要考虑重复元素，而不是去重后的第k大 。
>
>法一：快速选择
>即快排思想。每一轮快速选择后，将寻找的范围近似减半，即 `n + n/2 + n/4 + ... = n(1 + 1/2 + 1/4 + ...) --> 2n`， 时间复杂度为`O(n)`。
>
>法二：桶排序
>数据范围` 2 * 10^4 * sizeof(int) = 8 * 10^4 B ≈ 80MB`，勉强可以空间换时间。开一个80MB大小的数组`b`，`b[i]`则表示值为`i`的元素个数。从`b[n - 1]`开始往前收集，收集到的第k个数即是第k大。
>
>法三：手写堆
>得背且少考，而且没上面两个快

**法一：快速选择**

```c++
class Solution {
public:
    #define NaN (1e5 + 1) 
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < k) return NaN; // k异常

        auto qsort = [&](auto&& self, int left, int right, int k) ->int {
            if (left == right) return nums[left];

            // 快排模版一：选择ceil(n / 2)位置为枢纽x
            int x = nums[left + right + 1 >> 1];
            int i = left - 1, j = right + 1;
            while (i < j) {
                while (nums[++i] < x);
                while (nums[--j] > x);
                if (i < j) swap(nums[i], nums[j]);
            }
            // 完成此轮，i总是右半部分首位
            int rnum = right - i + 1; // 右半部分元素个数
            if (k <= rnum) return self(self, i, right, k); // 继续在右边找第k大
            else return self(self, left, i - 1, k - rnum); // 在左边找第 k - rnum 大即可

            // 快排模版二：选择floor(n / 2)位置为枢纽x
            // int x = nums[left + right >> 1];
            // int i = left - 1, j = right + 1;
            // while (i < j) {
            //     while (nums[++i] < x);
            //     while (nums[--j] > x);
            //     if (i < j) swap(nums[i], nums[j]);
            // }
            // // 完成一轮， j总是在左半部分尾
            // int rnum = right - j;
            // if (k <= rnum) return self(self, j + 1, right, k);
            // else return self(self, left, j, k - rnum);
        };

        return qsort(qsort, 0, n - 1, k);
    }
};
```

- 时间复杂度`O(n)`
- 空间复杂度`O(n)`，递归栈空间

这是闫总推荐的快排模版，我们熟悉快排思想即可，手撕还得用前人总结下来的模板，规避了重复值等特殊情况会带来的死循环。
模板要点：

1. 枢纽选择。无脑选择中间位置（`l + r + 1 >> 1`或者`l + r >> 1`）的值，这是最简单避免单调性的方法，写题够用；
2. `l + r + 1 >> 1`时，下一层递归参数用`i`,
   `l + r >> 1`时，下一层递归参数用`j`。

**法二：桶排序**

```c++
class Solution {
public:
    #define N 20001
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> bucket(N);

        // 将 -10000 ~ 10000 映射到 0 ~ 20000
        for (int num : nums) {
            bucket[num + 10000]++;
        }

        for (int i = 20000; i >= 0; --i) {
            k -= bucket[i];
            if (k <= 0) return i - 10000;
        }

        return N; // k异常
    }
};
```

- 时间复杂度：`O(数据范围)`
- 空间复杂度：`O(数据范围)`

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

>分析
>
>前k大使用小顶堆，前k小使用大顶堆。
>边遍历边入堆，当堆的size > k时，pop一下。这样的遍历方式使得当下的堆里始终是目前最大/小的k个值。

```c++
class Solution {
public:
    struct MyCompre {
        // 若用class记得声明为public
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs)const {
            // 小顶堆，其实现是从底向上 层层比较，rhs可以看成较上层
            return lhs.second > rhs.second; 
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        int n = nums.size();
        unordered_map<int, int> mp;        

        for (int num : nums) {
            mp[num]++;
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, MyCompre> que;
        for (const auto& p : mp) {
            que.emplace(p);
            if (que.size() > k) {
                que.pop();
            }
        }

        // 这里按大到小收集答案
        vector<int> res(k);
        for (int i = k - 1; i >= 0; --i) {
            res[i] = que.top().first; que.pop();
        }
        return res;
    }
};
```

- 时间复杂度：`O(nlogk)`，每次入堆`O(logk)`
- 空间复杂度：`O(n)`

### [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() `初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

**示例 1：**

```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

**提示:**

- `-105 <= num <= 105`
- 在调用 `findMedian` 之前，数据结构中至少有一个元素
- 最多 `5 * 104` 次调用 `addNum` 和 `findMedian`

> 分析
>
> 要`O(nlogn)`以上。
> 考虑用大根堆`lq`存前半段，小根堆`rq`存后半段，这样两个堆顶就是中间的值。
>
> - addNum时，优先放大根堆`lq`，保证有偶数个数时，两个堆size一样；奇数个时，左边的大根堆`lq`多一个
> - findMedian时，若两个堆size一样，则取两个堆顶出来求平均值，否则，直接返回大根堆`lq`的顶。

```c++
class MedianFinder {
    priority_queue<int> lq; // 大根堆
    priority_queue<int, vector<int>, greater<int>> rq; // 小根堆
public:
    MedianFinder() {

    }
    void addNum(int num) {
        if (lq.size() == rq.size()) { // 元素个数一样：优先放lq  
            if (lq.empty() || num <= rq.top()) {
                lq.push(num);
            } else {
                lq.push(rq.top()); rq.pop();
                rq.push(num);
            }       
        } else { // lq多一个元素: 搞成一样 
            if (num >= lq.top()) {
                rq.push(num);
            } else {
                rq.push(lq.top()); lq.pop();
                lq.push(num);
            }
        }
    }
    double findMedian() {
        if (lq.empty()) return -1e6;

        double ans;
        if (lq.size() == rq.size()) {
            ans = (lq.top() + rq.top()) / 2.0;
        } else {
            ans = lq.top();
        }
        return ans;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

- 时间复杂度：`O(nlogn)`
- 空间复杂度：`O(n)`

## 贪心算法

### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

>分析
>
>- 确定解空间：算出第`i(0 <= i < n)`天卖出可以获得的最大利润`p[i]`，答案就是`p[i]`中最大值。
>- 算法：遍历`prices`，过程中更新目前的最小值`min_price`，则第i天可以获得的最大利润就是`price[i] - min_price`，同时更新答案。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_price = 1000001;
        int ans = 0;

        for (int price : prices) {
            ans = max(ans, price - min_price);
            min_price = min(min_price, price);
        }
        return ans;
    }
};
```

### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`

> 分析
>
> 遍历过程中维护当前可以到达的最远下标`right_most`，若`right_most`能够到达`i`，则更新`right_most`，并判断是否已经可以到达最后下标。

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int right_most = 0;

        for (int i = 0; i < n; ++i) {
            if (i > right_most) break; // 到不了i
            right_most = max(nums[i] + i, right_most);
            if (right_most >= n - 1) return true;
        }
        return false;
    }
};
```

### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`

>解析
>
>![图片.png](https://pic.leetcode-cn.com/9d5016c6e660a452991185d23b7b4d98853b7c300453d79715b5e9a206085e44-%E5%9B%BE%E7%89%87.png)
>
>贪跳跃时机，只有当上一次跳跃范围不可达`i`时，才会跳。
>
>用`right_most`表示当前可到达的最远下标，`end`表示本次跳跃可以到达的最远下标。当`i == end`并且 `i` 未到达终点时，跳跃次数+1。

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        int right_most = 0; // 目前可达最远
        int end = 0; // 本次跳跃可达最远
        int ans = 0;
        
        for (int i = 0; i < n - 1; ++i) {
            if (right_most < i) return -1;
            right_most = max(right_most, nums[i] + i);
            if (end == i) {
                end = right_most;
                ans++;
                if (end >= n - 1) break;
            } 
        }
        return ans;
    }
};
```

### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

> 解析
>
> 1. 第一次遍历，用一个数组`rightmost[26]`记录26个字母最后一次出现的下标。
> 2. 第二次遍历，记录当前遍历过字母可达的最远下标`max_pos`，若`i == max_pos`，则划分出新的一段`[last_pos + 1, i]`，并更新：`last_pos = max_pos`

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int n = s.size();
        int rightmost[26];
        memset(rightmost, 0, sizeof rightmost);

        for (int i = 0; i < n; ++i) {
            rightmost[s[i] - 'a'] = i;
        }

        vector<int> res;
        int last_pos = -1;
        int max_pos = 0;
        for (int i = 0; i < n; ++i) {
            max_pos = max(max_pos, rightmost[s[i] - 'a']);
            if (i == max_pos) {
                res.push_back(i - last_pos);
                last_pos = max_pos;
            }
        }

        if (max_pos >= n) res.push_back(n - 1 - last_pos); // 最后一段
        return res;
    }
};
```

## 动态规划

1. 动规关键在于给出恰当的状态定义。这里主要分为3种：背包问题、子数组问题、子序列问题。背包问题可以先看一遍01背包、完全背包的推导过程，后续刷到同类型在此基础上推导即可；另外子数组问题、子序列问题都经历一遍自己推导的过程。最终只有背包问题稍微需要加点记忆，其他的顺着一般逻辑走即可。
2. 不好想的动规可以尝试记忆化搜索，从选与不选的角度入手；一般情况下，遇到较复杂的区间DP从记忆化搜索入手会简单些。

> 什么是记忆化搜索？
> —— 本质上是动规的递归实现。
>
> - 优点：1. 实现更简单快捷；2. 边界处理方便，无异于平时写递归出口
> - 缺点：1. 缓存和递归栈废空间，少数情况下会被卡； 2. 少数题实现起来反而复杂； 3. 可能“卡常”

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**提示：**

- `1 <= n <= 45`

> 分析
>
> 1. 状态定义：`f[n + 1]`：`f[i]`表示爬了n阶的方案数；
> 2. 递推式：`f[i] = f[i - 2] + f[i - 1]`;
> 3. 定义边界：`f[0] = f[1] = 1`，`f[0]`按照本题情况给的1，

**法一：一维线性dp**

```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> f(n + 1);
        f[0] = f[1] = 1;
        for (int i = 2; i <= n; ++i) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
};
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

**法二：一维线性dp空间优化**。只与前两个状态有关，并且只需保留最新值，故用两个变量滚动即可。

```c++
class Solution {
public:
    int climbStairs(int n) {
        int p = 0, q = 1, res = 0; // res = p + q;
        for (int i = 1; i <= n; ++i) { 
            res = p + q;
            p = q;
            q = res;
        }
        return res;
    }
};
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

### [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**提示:**

- `1 <= numRows <= 30`

> 分析
>
> 1. 状态定义：`f[n + 1][n + 1]`，`f[i][j]`表示第`i`行第`j`列的值
> 2. 递推式：`f[i][j] = f[i - 1][j - 1] + f[i - 1][j]`
> 3. 定义边界：`f[0][0...n]` = 0
>
> 实现时作参考即可

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;

        for (int i = 1; i <= numRows; ++i) { // 第i行
            vector<int> row(i, 1);
            for (int j = 1; j < i - 1; ++j) { // 两端就是1
                if (!res.empty()) {
                    row[j] = res.back()[j - 1] + res.back()[j]; 
                }
            }
            res.emplace_back(row);
        }
        return res;
    }
};
```

- 时间复杂度：`O(n^2)`
- 空间复杂度：`O(1)?`所用空间装要返回的结果，不算额外空间

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

> 分析
>
> 1. 状态定义：`f[n][2]`，
>
>    - `f[i][0]`表示i间房屋中，没偷第i间房屋情况下，可以偷窃到的最大金额
>    - `f[i][1]`表示i间房屋中，偷了第i间房屋情况下，可以偷窃到的最大金额
>
> 2. 递推式：
>
>    显然，房屋增多，偷窃金额可能会增多，但必不会减少，故`f[i]`只要考虑`f[i - 1]`即可
>
>    - `f[i][0] = max(f[i - 1][1], f[i - 1][0])`
>    - `f[i][1] = f[i - 1][0] + nums[i]`
>
> 3. 定义边界：`f[0][0] = 0, f[0][1] = nums[0]`

**法一：线性dp**

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;

        int n = nums.size();
        vector<vector<int>> f(n, vector<int>(2));
        f[0][1] = nums[0];
        for (int i = 1; i < n; ++i) {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] = f[i - 1][0] + nums[i];
        }
        return max(f[n - 1][0], f[n - 1][1]);
    }
};
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

**法二：线性dp空间优化**，只与`f[i - 1][0], f[i - 1][1]`有关，用两个变量滚动即可

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;

        int n = nums.size();
        // p: f[i][0], q:f[i][1]
        int p = 0, q = nums[0];
        for (int i = 1; i < n; ++i) {
            // p = max(p, q);
            // q = p + nums[i]; 这里的p已经不是上个状态的p了
            int temp_p = p; // 保存一下上个状态的p
            p = max(p, q);
            q = temp_p + nums[i];
        }
        return max(p, q);
    }
};
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

**法三：[记忆化搜索](https://leetcode.cn/link/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Xj411K7oF%2F)**，按照**选与不选**来决定递归路径，并且缓存已经到过的结点

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> memo(n, -1); // -1不在有效值范围内
        auto dfs = [&](auto&& self, int i)->int {
            if (i < 0) return 0;

            int &res = memo[i];
            if (res != -1) return res;
            return res = max(self(self, i - 2) + nums[i], 
                             self(self, i - 1));
        };
        return dfs(dfs, n - 1); // 从最后一间房子开始往回推
    }
};
```

- 时间复杂度：`O(n)`，子问题数量(n) × 子问题复杂度(一次max)
- 空间复杂度：`O(n)`

### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**提示：**

- `1 <= n <= 104`

> 分析
>
> **[完全背包问题](https://www.acwing.com/problem/content/description/3/)**：有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。
> 第 i 种物品的体积是 vi，价值是 wi。
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
>
> 1. - 状态定义: `f[N + 1][V + 1]`。 `f[i][j]`表示选择前 i 种，体积不超过 j 的最大价值
>    
>    - 二维递推式推导：`f[i][j] = max( f[i - 1][j], f[i - 1][j - vi] + wi, f[i - 1][j - vi * 2] + wi * 2, ... )`，
>      	 由于`f[i][j - vi] + wi = max( f[i - 1][j - vi] + wi, f[i - 1][j - vi * 2] + wi * 2, ... )`，代入上式
>      	
>        	可得 `f[i][j] = max( f[i - 1][j], f[i][j - vi] + wi )`(ps：式1表示选了0、1、2、3... 个物品 i )；
>      	
>    - 一维递推式：`f[j] = max(f[j], f[j - v[i]] + w[i])`。
>    
> 2. 模板代码
>
> ```c++
> // 无空间优化
> const int N = 1010;
> int f[N][N]; 
> int w[N], v[N]; 
> 
> int main() {
> 	int n, m;
> 	cin >> n >> m;
> 	for (int i = 1; i <= n; ++i) cin >> v[i] >> w[i];
> 	// f[i][j]表示选择前i种，体积不超过j的最大价值
> 	// f[i][j] = max(f[i - 1][j], f[i][j - v]);
> 	for (int i = 1; i <= n; i ++) {
> 		for (int j = 1; j <= m; j ++) {
> 			f[i][j] = f[i - 1][j]; // f[i - 1][j]是一定存在的
> 			if (j >= v[i]) {
> 				f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
> 			}
> 		}
> 	}
> 	cout << f[n][m] << endl;
> 	return 0;
> }
> 
> // 空间优化
> const int N = 1010;
> int f[N]; 
> int w[N], v[N]; 
> 
> int main() {
> 	int n, m;
> 	cin >> n >> m;
> 	for (int i = 1; i <= n; ++i) cin >> v[i] >> w[i];
> 	for (int i = 1; i <= n; i ++) {
> 		for (int j = v[i]; j <= m; j ++) {
> 			f[j] = max(f[j], f[j - v[i]] + w[i]);
> 		}
> 	}
> 	cout << f[m] << endl;
> 	return 0;
> }
> ```
>
> 
>
> **法一：完全背包变种**
>
> ​	这里N = sqrt(n)， 容量V = n，每件物品 i 的体积是 i * i，价值都是1。
> ​	求解哪些物品装入背包，使得这些物品的总体积刚好**等于**背包容量，且总价值**最小**。
>
> - 递推式：`f[i][j] = min( f[i - 1][j], f[i][j - i * i] + 1)`
>
> 二维实现
>
> ```c++
> class Solution {
> public:
>     int numSquares(int n) {
>         // f[i][j] = min(f[i - 1][j], f[i][j - i * i] + 1);
>         int N = sqrt(n);
>         int V = n;
>         vector<vector<int>> f(N + 1, vector<int>(V + 1, V + 1)); // n + 1表示没有符合答案
>         // 边界处理: f[][0] = 0
>         for (int i = 0; i <= N; ++i) f[i][0] = 0;
> 
>         for (int i = 1; i <= N; ++i) {
>             int v = i * i;
>             for (int j = 1; j <= V; ++j) {
>                 f[i][j] = f[i - 1][j];
>                 if (j >= v) {
>                     f[i][j] = min(f[i][j], f[i][j - v] + 1);
>                 }
>             }
>         }
>         return f[N][V];
>     }
> };
> ```
>
> - 时间复杂度：`O(NV)`，N是物品数量，V是背包容量
> - 空间复杂度：`O(NV)`
>
> 一维实现
>
> 当前状态只与上一层相关，
>
> ```c++
> class Solution {
> public:
>     int numSquares(int n) {
>         // f[i][j] = min(f[i - 1][j], f[i][j - i * i] + 1);
>         int N = sqrt(n);
>         int V = n;
>         vector<int> f(V + 1, V + 1); 
>         f[0] = 0; // j为0是边界
>         for (int i = 1; i <= N; ++i) {
>             int v = i * i;
>             for (int j = v; j <= V; ++j) {
>                 f[j] = min(f[j], f[j - v] + 1);
>             }
>         }
> 
>         return f[V];
>     }
> };
> ```
>
> - 时间复杂度：`O(NV)`，N是物品数量，V是背包容量
> - 空间复杂度：`O(V)`
>
> **法二：[记忆化搜索](https://leetcode.cn/problems/perfect-squares/solutions/2830762/dong-tai-gui-hua-cong-ji-yi-hua-sou-suo-3kz1g)**
>
> 1. 定义 dfs(i,j) 表示从前 i 个完全平方数中选一些数（可以重复选），满足元素和恰好等于 j，最少要选的数字个数。
>     考虑第 i 个完全平方数 i^2 选或不选，然后取最小值：
>
>   `dfs(i, j) = min( dfs(i - 1, j), dfs(i, j - i * i) + 1 )`
>
> 2. 递归边界：
>    - 正常结束：j == 0；
>    - 异常结束：
>       - j < 0，用了过大的数
>       - i == 0，i 是从正数往下走的，走到0表示枚举完了（ps：怎么理解更好）。
>
> 
>
> ``` c++
> class Solution {
> public:
>     int numSquares(int n) {
>         if (n <= 0) return 0;
> 
>         int m = sqrt(n);
>         vector<vector<int>> memo(m + 1, vector<int>(n + 1, -1));
>         auto dfs = [&](auto&& self, int i, int j)->int {
>             if (j == 0) return 0; // 正常结束
>             if (j < 0 || i == 0) return 10001; // 异常结束
> 
>             int &res = memo[i][j];
>             if (res != -1) return res;
>             return res = min(self(self, i - 1, j), self(self, i, j - i * i) + 1);
>         };
>         return dfs(dfs, m, n); 
>     }
> };
> ```
>
> - 时间复杂度：`O(n·sqrt(n))`
> - 空间复杂度: `O(n·sqrt(n))`

### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

>分析
>
>跟**完全平方数**基本一致，区别是物品价值为`coins[i]`，实现的时候取`v[i]`需要注意下标 -1。
>
>**法一：完全背包变种**
>
>二维
>
>```c++
>class Solution {
>public:
>    int coinChange(vector<int>& coins, int amount) {
>        int N = coins.size(), V = amount;
>        vector<vector<int>> f(N + 1, vector<int>(V + 1, V + 1)); 
>        for (int i = 0; i <= N; ++i) f[i][0] = 0;
>
>        for (int i = 1; i <= N; ++i) {
>            int v = coins[i - 1]; // 注意索引
>            for (int j = 1; j <= V; ++j) {
>                f[i][j] = f[i - 1][j];
>                if (j >= v) {
>                    f[i][j] = min(f[i][j], f[i][j - v] + 1);
>                }
>            }
>        } 
>        return f[N][V] == V + 1 ? -1 : f[N][V];
>    }
>};
>```
>
>- 时间复杂度：`O(NV)`，N是物品数量，V是背包容量
>- 空间复杂度：`O(V)`
>
>一维
>
>```c++
>class Solution {
>public:
>    int coinChange(vector<int>& coins, int amount) {
>        int N = coins.size(), V = amount;
>        vector<int> f(V + 1, V + 1);
>        f[0] = 0;
>
>        for (int i = 1; i <= N; ++i) {
>            int v = coins[i - 1]; // 注意索引
>            for (int j = v; j <= V; ++j) {
>                f[j] = min(f[j], f[j - v] + 1);
>            }
>        } 
>        return f[V] == V + 1 ? -1 : f[V];
>    }
>};
>```
>
>- 时间复杂度：`O(NV)`，N是物品数量，V是背包容量
>- 空间复杂度：`O(V)`

### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**

> 分析
>
> **借鉴完全背包的状态定义**
>
> 1. 状态定义：`f[i][j]`表示利用wordDict中前i个单词，是否可以拼出s中前j个字符组成的子字符串。但是显然，wordDict中每去掉一个单词后，拼成s的成功率只减不增，故 i 这一维是无需考虑的，肯定是考虑wordDict中所有单词都试一遍。
>
>    故改成`f[i]`: 表示s中前i个字符组成的子字符串是否可以被wordDict拼成。
>
> 2. 递推式：`f[i] = f[i - word.size()] && s.substr(i - word.size(), word.size()) == word`**(word ∈ wordDict)**
>
> 3. 答案： `max(f[i])`
>
> ```c++
> class Solution {
> public:
>     bool wordBreak(string s, vector<string>& wordDict) {
>         int V = s.size();
>         vector<bool> f(V + 1);
>         f[0] = true;
> 
>         for (int i = 1; i <= V; ++i) {
>             for (auto& word : wordDict) {
>                 int v = word.size();
>                 if (i - v >= 0) {
>                     f[i] = f[i] || (f[i - v] && s.substr(i - v, v) == word);
>                 }
>             }
>         }
>         return f[V];
>     }
> };
> ```
>
> - 时间复杂度：`O(VN)`，V是字符串长度，N是wordDiict长度
> - 空间复杂度：`O(V)`

### [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

>分析
>
>**法一：dp**
>
>1. 状态定义：`f[n]`。`f[i]`表示以i结尾的最大递增子序列长度；
>2. 递推: `f[i] = max(f[j] + 1), when (f[i] > f[j]) 其中j ∈ [0, i-1]`；
>3. 所以结尾的最大递增子序列长度中，选出最大值。
>
>```c++
>class Solution {
>public:
>    int lengthOfLIS(vector<int>& nums) {
>        int n = nums.size();
>        vector<int> f(n, 1);
>
>        int ans = 0;
>        for (int i = 0; i < n; ++i) {
>            for (int j = 0; j < i; ++j) {
>                if (nums[i] > nums[j]) {
>                    f[i] = max(f[i], f[j] + 1);
>                }
>            }
>            ans = max(ans, f[i]);
>        }
>        return ans;
>    }
>};
>```
>
>- 时间复杂度：`O(n^2)`
>- 空间复杂度：`O(n)`
>
>**法二：贪心**
>
>```c++
>class Solution {
>public:
>    int lengthOfLIS(vector<int>& nums) {
>        // 原地贪心 + 二分
>        // 遍历过程中维护一个递增子序列的长度
>        auto end = nums.begin(); // 所维护序列的尾元素迭代器
>        for (int num : nums) {
>            // 若用upper_bound，则是最长非递减序列
>            auto it = lower_bound(nums.begin(), end, num);
>            *it = num;
>            if(it == end) end++;
>        }
>
>        return end - nums.begin();
>    }
>};
>```
>
>- 时间复杂度：`O(nlogn)`
>- 空间复杂度：`O(1)`
>
>进阶：如果是求最长子序列，可用线段树

### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组。

（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**提示:**

- `1 <= nums.length <= 2 * 104`
- `-10 <= nums[i] <= 10`
- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位** 整数

>分析
>子数组问题。
>
>**失败尝试**
>
>1. 状态定义：`f[n][2]`。`f[i][0]`表示以`f[i]`结尾并且不选`f[i]`的最大连续乘积，反之，选`f[i]`的最大连续乘积。
>
>2. 递推式：`f[i][1] = max(nums[i], f[i - 1][0], f[i - 1][1] * nums[i])`;
>
>   ​               `f[i][0] = max(f[i - 1][0], f[i - 1][1])`;	
>
>3. 答案：`max(f[n - 1][0], f[n - 1][1])`。
>
>```c++
>class Solution {
>public:
>    int maxProduct(vector<int>& nums) {
>        if (nums.empty()) return 0;
>
>        int n = nums.size();
>        vector<vector<int>> f(n, vector<int>(2)); 
>        f[0][1] = nums[0]; 
>        f[0][0] = INT_MIN; // 注意
>        for (int i = 1; i < n; ++i) {
>            f[i][1] = max(nums[i], f[i - 1][1] * nums[i]);
>            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
>            cout << i << ' ' << f[i][1] << ' ' << f[i][0] << endl; 
>        }
>
>        return max(f[n - 1][0], f[n - 1][1]);
>    }
>};
>
>错误用例：
>输入
>nums = [-2,3,-4]
>标准输出
>1 3 -2 
>2 -4 3
>输出
>3
>预期结果
>24
>```
>
>发现 i = 2时， nums[i] = -4，最大乘积应该是`[-2, 3, -4]`的乘积。而`f[i]`只维护了最大值，这里可知当 nums[i] 为负数时，应该再维护一个最小值。
>
>**修改后**
>不仅要维护一个最正值，还要维护一个最负值。所以数组至少需要开两维，考虑到原来选与不选实际可以去掉，像**最大递增子序列**那样，迭代过程中更新结果即可。最后：
>
>1. 状态定义: `f[n][2]`。`f[i][0]`表示以 i 结尾的最大连续乘积，`f[i][1]`表示以 i 结尾的最小连续乘积。
>
>2. 递推式：`f[i][0] = max(nums[i], nums[i] * f[i - 1][0], nums[i] * f[i - 1][1])`；
>
>   ​	     `f[i][1] = min(nums[i], nums[i] * f[i - 1][0], nums[i] * f[i - 1][i])`；
>
>3. 答案：过程中用`f[i][0]`维护即可。
>
>```c++
>class Solution {
>public:
>    int maxProduct(vector<int>& nums) {
>        int n = nums.size();
>        vector<vector<int>> f(n, vector<int>(2));
>        int ans = INT_MIN;
>        for (int i = 0; i < n; ++i) {
>            f[i][0] = f[i][1] = nums[i];
>            if (i > 0) {
>                f[i][0] = max({f[i][0], nums[i] * f[i - 1][0], nums[i] * f[i - 1][1]});
>                f[i][1] = min({f[i][1], nums[i] * f[i - 1][0], nums[i] * f[i - 1][1]});
>            }
>            ans = max(ans, f[i][0]);
>        }
>        return ans;
>    }
>};
>```
>
>- 时间复杂度：`O(n)`；
>- 空间复杂度: `O(n)`；

### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```c++
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

>分析
>
>令 target = sum / 2。即问题为，使用nums中的数 (每个数只能用一次)，能否使得之和等于target。
>
>**01背包**
>有一个体积为V的背包，提供N种物品，物品体积为v[i]， 价值为w[i]，每种物品只有一个，求这个背包可以装下的最大价值。
>二维推导式：`f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i])`， 选与不选；
>一维推导式：`f[j] = max(f[j], f[j - v[i]] + w[i]);`
>
>一维模板
>
>```c++
>vector<int> f(V + 1);
>for (int i = 1; i <= N; ++i) {
>    for (int j = V; j >= v[i]; ++j) { // 需要上一层的 j - v[i]
>        f[j] = max(f[j], f[j - v[i]] + w[i]);
>    }
>}
>```
>
>**回到本题**
>
>V = target, N = num.size(), v[i] = w[i]  = nums[i]。这样，装背包方案的最大价值 = 最大体积 --> 不会超过V。在此基础上，能否问题直接转化为最大价值 f[V]是否为V。
>
>1. 状态定义：`f[V]`。`f[i]`表示能否用nums凑出`f[i]`;
>2. 递推式： `f[i] = f[i] || f[i - nums[i]], nums[i] ∈ nums`;
>3. 答案; `f[n] == V`。
>
>```c++
>class Solution {
>public:
>    bool canPartition(vector<int>& nums) {
>        int sum = accumulate(nums.begin(), nums.end(), 0);
>        if (sum % 2) return false;
>
>        int V = sum / 2;
>        int N = nums.size();
>        // 01背包问题
>        vector<int> f(V + 1);
>        for (int i = 1; i <= N; ++i) {
>            int v = nums[i - 1];
>            for (int j = V; j >= v; --j) {
>                f[j] = max(f[j], f[j - v] + v);
>            }
>        }
>        return f[V] == V;
>    }
>};
>```
>
>- 时间复杂度：`O(NV)`；
>- 空间复杂度: `O(V)`；

### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`

> 分析
>
> **法一：动规**
>
> 属于子数组问题。
>
> 1. 状态定义：`f[n]`。`f[i]`表示以i为结尾的最长有效括号长度。
>
> 2. 递推式: 分类讨论
>
>         —— 当s[i] == '(', f[i] = 0
>         —— 当s[i] == ')'
>            —— 若s[i - 1] == '('， f[i] = f[i - 2] + 2 
>            —— 若s[i - 1] == ')'
>                —— 若s[i - 1 - f[i - 1]] == '(', f[i] = f[i - 2 - f[i - 1]] + 2 + f[i - 1]; 
>                —— 否则, f[i] = 0;  
>
> 3. 实现起来边界处理有点麻烦，不如滑窗。
>
> ```c++
> class Solution {
> public:
>     int longestValidParentheses(string s) {
>         int n = s.size();
>         vector<int> f(n + 2);
> 
>         for (int i = 1; i < n; ++i) {
>             if (s[i] == '(') {
>                 f[i + 2] = 0;
>             } else { // s[i] == ')'
>                 if (s[i - 1] == '(') {
>                     f[i + 2] = f[i] + 2;
>                 } else if (i - 1 - f[i + 1] >= 0 && s[i - 1 - f[i + 1]] == '(') {
>                     f[i + 2] = f[i - f[i + 1]] + f[i + 1] + 2 ;
>                 }
>             }
>         }
> 
>         return *max_element(f.begin(), f.end());
>     }
> };
> ```
>
> - 时间复杂度：`O(n)`;
> - 空间复杂度：`O(n)`;
>
> **法二：滑动窗口**
>
> **失败尝试**
>
> 窗口内统计左右括号数。
> 滑动策略：左指针i，右指针j 。j在for循环中++，当窗口内左括号数 lnum < 有括号数 rnum时，i++。
>
> ```c++
> class Solution {
> public:
>     int longestValidParentheses(string s) {
>         // 滑窗，j放for里移动，滑动过程中维护左右括号数量
>         // 当左括号少于右括号时，移动i。
>         int n = s.size();
>         int lnum = 0, rnum = 0; // 滑窗内左、右括号数量
> 
>         auto count = [&](char c, bool is_add) {
>             if (is_add) c == '(' ? lnum++ : rnum++; 
>             else c == '(' ? lnum-- : rnum--;
>         };
> 
>         int ans = 0;
>         for (int i = 0, j = 0; j < n; ++j) {
>             count(s[j], true);
>             while (lnum < rnum && i <= j) {
>                 count(s[i++], false);
>             }
>             if (lnum == rnum) {
>                 // 更新答案
>                 ans = max(ans, lnum * 2);
>             }
>         }   
>         return ans;
>     }
> };
> ```
>
> 对于输入 `s = "(()"`，输出为0(应为2)。
> **此法不能正确处理左括号多余的情况（不会更新答案，相当于没处理），但能正确处理右括号多余的情况。**那补上一个逆操作，正好互补！逆操作就是：从右向左遍历，滑动策略改为，j 在for循环中 --，当左括号数大于右括号数时，i --。
>
> **两次滑窗**
>
> ```c++
> class Solution {
> public:
>     int longestValidParentheses(string s) {
>         int n = s.size();
>         int lnum = 0, rnum = 0; // 滑窗内左、右括号数量
> 
>         auto count = [&](char c, bool is_add) {  // 维护lnum, rnum
>             if (is_add) c == '(' ? lnum++ : rnum++; 
>             else c == '(' ? lnum-- : rnum--;
>         };
> 
>         int ans = 0;
>         for (int i = 0, j = 0; j < n; ++j) {
>             count(s[j], true);
>             while (lnum < rnum && i <= j) {
>                 count(s[i++], false);
>             }
>             if (lnum == rnum) {
>                 ans = max(ans, lnum * 2);
>             }
>         }   
>         lnum = rnum = 0;
>         for (int i = n - 1, j = n - 1; j >= 0; --j) {
>             count(s[j], true);
>             while (lnum > rnum && i >= j) {
>                 count(s[i--], false);
>             }
>             if (lnum == rnum) {
>                 ans = max(ans, lnum * 2);
>             }
>         }
>         return ans;
>     }
> };
> ```
>
> - 时间复杂度：`O(n)`;
> - 空间复杂度：`O(1)`;

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)

```
输入：m = 3, n = 7
输出：28
```

**提示：**

- `1 <= m, n <= 100`
- 题目数据保证答案小于等于 `2 * 109`

> 分析
>
> 1. 状态定义：`f[m + 1][n + 1]`。`f[i][j]`表示从左上角到（i, j）处的路径数。
> 2. 递推式：`f[i][j] = f[i - 1][j] + f[i][j - 1]`;
> 3. 边界：`f[0][1] = 1 or f[1][0] = 1`。只有使得`f[1][1] = 1`才能传递下去。
>
> ```c++
> class Solution {
> public:
>     int uniquePaths(int m, int n) {
>         if (m == 0 && n == 0) return 0;
> 
>         vector<vector<int>> f(m + 1, vector<int>(n + 1));
>         //边界
>         f[0][1] = 1;
>         for (int i = 1; i <= m; ++i) {
>             for (int j = 1; j <= n; ++j) {
>                 f[i][j] = f[i - 1][j] + f[i][j - 1];
>             }
>         }
>         return f[m][n];
>     }
> };
> ```
>
> - 时间复杂度：`O(mn)`;
> - 空间复杂度：`O(mn)`;
>
> 空间优化
>
> 推导式变化跟逻辑无关，看着原来的改即可。但边界需要联系题目背景设置好。
>
> ```c++
> class Solution {
> public:
>     int uniquePaths(int m, int n) {
>         if (m == 0 && n == 0) return 0;
> 
>         vector<int> f(n + 1);
>         for (int i = 1; i <= m; ++i) {
>             f[1] = 1; // 边界
>             for (int j = 2; j <= n; ++j) {
>                 f[j] = f[j] + f[j - 1];
>             }
>         }
> 
>         return f[n];
>     }
> };
> ```
>
> - 时间复杂度：`O(mn)`;
> - 空间复杂度：`O(n)`;

### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

> 分析
>
> 1. 状态定义：`f[m + 1][n + 1]`。`f[i][j]`表示从左上角到（i, j）处的最小数字总和。
> 2. 递推式：`f[i][j] = min(f[i - 1][j], f[i][j - 1]) + gird[i][j]` ，每个格子只有左、上两个来源。
> 3. 边界：`f[0][1] = 0 or f[1][0] = 0`。只有使得`f[1][1] = grid[0][0]`才能传递下去。
>
> ```c++
> class Solution {
> public:
>     int minPathSum(vector<vector<int>>& grid) {
>         int m = grid.size(), n = grid[0].size();
>         vector<vector<int>> f(m + 1, vector<int>(n + 1, INT_MAX));
> 		// 边界
>         f[0][1] = 0;
>         for (int i = 1; i <= m; ++i) {
>             for (int j = 1; j <= n; ++j) {
>                 f[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i - 1][j - 1];
>             }
>         }
>         return f[m][n];
>     }
> };
> ```
>
> - 时间复杂度：`O(mn)`;
> - 空间复杂度：`O(mn)`;
>
> 空间优化
>
> 只有使得每一层的`f[1] = grid[][0]`才能正确传递下去。
>
> ```c++
> class Solution {
> public:
>     int minPathSum(vector<vector<int>>& grid) {
>         int m = grid.size(), n = grid[0].size();
>         vector<int> f(n + 1, INT_MAX);
> 
>         f[1] = grid[0][0]; // f[0] = 0不行，会错误到第二及后续行的第一个值
>         for (int i = 1; i <= m; ++i) {
>             for (int j = 1; j <= n; ++j) {
>                 if (i == 1 && j == 1) continue;
>                 f[j] = min(f[j], f[j - 1]) + grid[i - 1][j - 1];
>             }
>         }
>         return f[n];
>     }
> };
> ```
>
> - 时间复杂度：`O(mn)`;
> - 空间复杂度：`O(n)`;

### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母组成

> 分析
>
> **法一：区间dp**
> 区间DP属于线性DP的一种，它以区间长度作为“阶段”。
>
> 1. 状态定义：`f[n][n]`，`f[i][j]`表示 [i, j]是否为回文子串。
>
> 2. 递推式：
>
>    —— 枚举“阶段”，即长度 L -> 2 ~ n ：
>
>    ​	—— 枚举左端点 i ，则右端点`j = i + L - 1` ：
>
>    ​		-- 若`s[i] != s[j]` ，`f[i][j] = false`; 
>
>    ​		-- 若 `s[i] == s[j]`
>
>    ​			-- 若 L <= 3，`f[i][j] = true` 
>
>    ​			-- 若 L > 3，`f[i][j] = f[i + 1][j - 1]`
>
> 3. 过程中更新答案即可。
>
> ```c++
> class Solution {
> public:
>     string longestPalindrome(string s) {
>         if (s.empty()) return "";
> 
>         int n = s.size();
>         vector<vector<bool>> f(n, vector<bool>(n));
> 
>         int maxL = 1;
>         int start = 0;
>         for (int L = 2; L <= n; ++L) { // 阶段
>             for (int i = 0; i < n; ++i) { // 左端点
>                 int j = i + L - 1; // 右端点
>                 if (j >= n) break;
> 
>                 if (s[i] != s[j]) {
>                     f[i][j] = false;
>                 } else {
>                     if (L <= 3) { // 相当于初值处理
>                         f[i][j] = true;
>                     } else {
>                         f[i][j] = f[i + 1][j - 1];
>                     }
>                 }
> 
>                 if (f[i][j] && L > maxL) {
>                     maxL = L;
>                     start = i;
>                 }
>             } 
>         }
> 
>         return s.substr(start, maxL);
>     }
> };
> ```
>
> - 时间复杂度：`O(n^2)`;
> - 空间复杂度：`O(n^2)`;
>
> **法二：中心扩散法**
>
> 回文字符串的中心：当长度为奇数时，为1个字符；当长度为偶数时，为两个字符。
> 中心扩散法就是遍历中心，对于每一中心，向两边扩展，当扩展到`s[i] != s[j]`时停下，则该中心的最长回文子串长度为
> ` j - i - 1`。
>
> ```c++
> class Solution {
> public:
>     string longestPalindrome(string s) {
>         int n = s.size();
>         int maxL = 0, start = 0;
> 
>         for (int i = 0; i < n; ++i) { // 遍历中心
>             for (int j = 0; j <= 1; ++j) { 
>                 // j = 0时，中心是1个点，j = 1时，中心是2个点 
>                 int left = i, right = i + j;
>                 while (left >= 0 && right < n && s[left] == s[right]) {
>                     left--;
>                     right++;
>                 }
>                 int L = right - left - 1;
>                 if (L > maxL) {
>                     maxL = L;
>                     start = left + 1;
>                 }
>             }
>         }
>         return s.substr(start, maxL);
>     }
> };
> ```
>
> - 时间复杂度：`O(n)`;
> - 空间复杂度：`O(1)`;

### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

**提示：**

- `1 <= text1.length, text2.length <= 1000`
- `text1` 和 `text2` 仅由小写英文字符组成。

> 分析
>
> 1. 状态定义：`f[n+1][m+1]`。`f[i][j]表示`text1以第 i 个字符为结尾、text2以第 j 个 为结尾的最长公共子序列长度。
>
> 2. 递推式：若`text1[i] == text2[j]`， `f[i][j] = f[i - 1][j - 1] + 1`
>
>    ​	       若`text1[i] != text2[j]`，`f[i][j] = max(f[i - 1][j], f[i][j - 1])`；
>
> 3.  目标值：`f[n][m]`;
>
> ```c++
> class Solution {
> public:
>     int longestCommonSubsequence(string text1, string text2) {
>         int n = text1.size(), m = text2.size();
>         vector<vector<int>> f(n + 1, vector<int>(m + 1));
> 
>         for (int i = 1; i <= n; ++i) {
>             for (int j = 1; j <= m; ++j) {
>                 if (text1[i - 1] == text2[j - 1]) { // 注意索引
>                     f[i][j] = f[i - 1][j - 1] + 1;
>                 } else {
>                     f[i][j] = max(f[i - 1][j], f[i][j - 1]);
>                 }
>             }
>         }
>         return f[n][m];
>     }
> };
> ```
>
> - 时间复杂度：`O(n^2)`;
> - 空间复杂度：`O(n^2)`;
>
> **空间优化**
> 当前状态，与 左(`f[i][j - 1]`)、左上(`f[i - 1][j - 1]`)、上(`f[i - 1][j]`) 三个状态有关。
> 优化掉一维后，
>
> - 上 直接取最近的 `f[j]`即可；
> - 左 直接取最近的 `f[j - 1]`即可；
> - 左上 即上一个状态的上(`f[j - 1]`) ，需要一个额外变量pre来维护。
>
> ```c++
> class Solution {
> public:
>     int longestCommonSubsequence(string text1, string text2) {
>         int n = text1.size(), m = text2.size();
>         vector<int> f(m + 1);
> 
>         for (int i = 1; i <= n; ++i) {
>             int pre = 0;
>             for (int j = 1; j <= m; ++j) {
>                 int t = f[j]; // 
>                 if (text1[i - 1] == text2[j - 1]) {
>                     f[j] = pre + 1;
>                 } else {
>                     f[j] = max(f[j], f[j - 1]);
>                 }
>                 pre = t;
>             }
>         }
>         return f[m];
>     }
> };
> ```
>
> - 时间复杂度：`O(n^2)`;
> - 空间复杂度：`O(n)`;

### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

> 分析
> 跟最长公共子序列差别不大。关键在于将插入、删除、替换转化成递推式的形式。
>
> 1. 状态定义：`f[n+1][m+1]`。`f[i][j]`表示`word1`以第 i 个为结尾、`word2`以第 j 个为结尾的最短编辑距离。
>
> 2. 递推式：若`word1[i] == word2[j]`， `f[i][j] = f[i - 1][j - 1]`
>
>    ​	       若`word1[i] != word2[j]`
>
>    ​			-- 选择插入，则`f[i][j] = f[i][j - 1]`，即在`word1[i]`后面插入`word[j]`;
>
>    ​			-- 选择删除，则`f[i][j] = [i - 1][j]`，即删除`word[i]`；
>
>    ​			-- 选择替换，则`f[i][j] = f[i - 1][j - 1]`，即将`word[i]`替换成`word[j]`；
>
>    ​			即`f[i][j] = min({f[i][j - 1], [i - 1][j], f[i - 1][j - 1]});` 
>
> 3. **初值**：`f[i][0] = i`，`f[0][j] = j`，其余为0；（为啥不能是 `f[0][0] = 0`，其余为无穷大？）
>
> 4. 目标值：`f[n][m]`。
>
> ```c++
> class Solution {
> public:
>     int minDistance(string word1, string word2) {
>         int n = word1.size(), m = word2.size();
>         vector<vector<int>> f(n + 1, vector<int>(m + 1)); 
>         // 初值
>         for (int i = 0; i <= n; ++i) f[i][0] = i;
>         for (int j = 0; j <= m; ++j) f[0][j] = j;
>         
>         for (int i = 1; i <= n; ++i) {
>             for (int j = 1; j <= m; ++j) {
>                 if (word1[i - 1] == word2[j - 1]) {
>                     f[i][j] = f[i - 1][j - 1];
>                 } else {
>                     // 插入、删除、替换
>                     f[i][j] = min({f[i][j - 1], f[i - 1][j], f[i - 1][j - 1]}) + 1;
>                 }
>             }
>         }
>         return f[n][m];
>     }
> };
> ```
>
> - 时间复杂度：`O(n^2)`;
> - 空间复杂度：`O(n^2)`;
>
> 空间优化
>
> 跟最长公共子序列的优化差不多，区别是初值。
