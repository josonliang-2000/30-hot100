> 前置知识点
>
> 1. 一般默认限时1s ≈ 10^8语句频度， 即数据规模`n < 10^4`情况下，才可以使用`O(n^2)`的算法；
> 2. 笔试一般空间限制 64MB / 128MB， hot100而言基本不需要考虑空间限制；

## 哈希

### [1.两数之和](https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 ：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**

> 分析
>
> 1. 数组中同一个元素在答案里不能重复出现 --> 每个元素只能用一次
> 2. 数据保证只有一组答案 --> 不存在重复元素
> 3. 数据保证数组元素个数大于等于2 --> 无需特判

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> mp;

        for (int i = 0; i < n; ++i) {
            int key = target - nums[i];
            if (mp.find(key) != mp.end()) {
                return {mp[key], i};
            }
            mp.emplace(nums[i], i);
        }

        return {};
    }
};
```

- 时间复杂度：`O(n)`
- 空间负责度：`O(n)`

## 栈

### [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

> 分析
>
> 1. 不能二重循环`O(n^2)`
>
> 2. 能勾勒的最大矩形，其顶部一定是某个柱子的顶部。
>
>    反证法：假设存在一个最大矩形，其顶部不是任何一个柱子的顶部。这说明矩形还能往上再增大，与最大相矛盾。
>
> 3. 由2可知，枚举heights，并在`O(1)`复杂度内计算出，以`height[i]`为顶部时可以获得的最大矩形`rect[i]`，
>
>    最终取最大的`rect[i] (0 <= i < n )` 即为答案。
>
>    - 如何`O(1)`复杂度计算出以`height[i]`为顶部时可以获得的最大矩形：当高度为`height[i]`，只需求维持该高度的最大宽度，假设已知`i`左边比height[i]小的最大下标` left[i]`、`i`右边比`height[i]`小的最小下标`right[i]`，则最大宽度= `right[i] - left[i] - 1`。
>
>    - rleft和right都可以利用单调栈在O(n)遍历中求得。对于求`right`，相当于从`i`往右走，找到最近的比`height[i]`小的下标，故从左开始遍历，使用单调增栈操作；对于所求`left`，则反过来从右开始遍历即可。（为啥使用单调增栈？ —— 以求right为例，即遇到比当前大的进栈，遇到比当前小的出栈，出栈时收集k）
>    

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        // left[i]、right[i]分别表示左、右两边最靠近的比height[i]小的元素下标
        vector<int> left(n, -1), right(n, n); // 遵循开区间
        vector<int> st; // 单调增栈

        // 先求right
        for (int i = 0; i < n; i++) {
            int x = heights[i];
            // 出栈
            while (!st.empty() && x < heights[st.back()]) {
                right[st.back()] = i; st.pop_back();
            }
            // 入栈
            st.push_back(i);
        }

        st.clear();
        // 求left
        for (int i = n - 1; i >= 0; i--) {
            int x = heights[i];
            while (!st.empty() && x < heights[st.back()]) {
                left[st.back()] = i; st.pop_back();
            }
            st.push_back(i);
        }

        // 枚举柱子
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int s = heights[i] * (right[i] - left[i] - 1);
            ans = max(ans, s);
        }

        return ans;
    }
};
```

- 时间复杂度：`O(n)`，求left和right 2n + 枚举 n = 3n
- 空间复杂度：`O(n)`

## 堆

### [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

>分析
>需要考虑重复元素，而不是去重后的第k大 。
>
>法一：快速选择
>即快排思想。每一轮快速选择后，将寻找的范围近似减半，即 `n + n/2 + n/4 + ... = n(1 + 1/2 + 1/4 + ...) --> 2n`， 时间复杂度为`O(n)`。
>
>法二：桶排序
>数据范围` 2 * 10^4 * sizeof(int) = 8 * 10^4 B ≈ 80MB`，勉强可以空间换时间。开一个80MB大小的数组`b`，`b[i]`则表示值为`i`的元素个数。从`b[n - 1]`开始往前收集，收集到的第k个数即是第k大。
>
>法三：手写堆
>得背且少考，而且没上面两个快

法一：快速选择

```c++
class Solution {
public:
    #define NaN (1e5 + 1) 
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        if (n < k) return NaN; // k异常

        auto qsort = [&](auto&& self, int left, int right, int k) ->int {
            if (left == right) return nums[left];

            // 快排模版一：选择ceil(n / 2)位置为枢纽x
            int x = nums[left + right + 1 >> 1];
            int i = left - 1, j = right + 1;
            while (i < j) {
                while (nums[++i] < x);
                while (nums[--j] > x);
                if (i < j) swap(nums[i], nums[j]);
            }
            // 完成此轮，i总是右半部分首位
            int rnum = right - i + 1; // 右半部分元素个数
            if (k <= rnum) return self(self, i, right, k); // 继续在右边找第k大
            else return self(self, left, i - 1, k - rnum); // 在左边找第 k - rnum 大即可

            // 快排模版二：选择floor(n / 2)位置为枢纽x
            // int x = nums[left + right >> 1];
            // int i = left - 1, j = right + 1;
            // while (i < j) {
            //     while (nums[++i] < x);
            //     while (nums[--j] > x);
            //     if (i < j) swap(nums[i], nums[j]);
            // }
            // // 完成一轮， j总是在左半部分尾
            // int rnum = right - j;
            // if (k <= rnum) return self(self, j + 1, right, k);
            // else return self(self, left, j, k - rnum);
        };

        return qsort(qsort, 0, n - 1, k);
    }
};
```

- 时间复杂度`O(n)`
- 空间复杂度`O(n)`，递归栈空间

这是闫总推荐的快排模版，我们熟悉快排思想即可，手撕还得用前人总结下来的模板，规避了重复值等特殊情况会带来的死循环。
模板要点：

1. 枢纽选择。无脑选择中间位置（`l + r + 1 >> 1`或者`l + r >> 1`）的值，这是最简单避免单调性的方法，写题够用；
2. `l + r + 1 >> 1`时，下一层递归参数用`i`,
   `l + r >> 1`时，下一层递归参数用`j`。

法二：桶排序

```c++
class Solution {
public:
    #define N 20001
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> bucket(N);

        // 将 -10000 ~ 10000 映射到 0 ~ 20000
        for (int num : nums) {
            bucket[num + 10000]++;
        }

        for (int i = 20000; i >= 0; --i) {
            k -= bucket[i];
            if (k <= 0) return i - 10000;
        }

        return N; // k异常
    }
};
```

- 时间复杂度：`O(数据范围)`
- 空间复杂度：`O(数据范围)`

### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

**提示：**

- `1 <= nums.length <= 105`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

>分析
>
>前k大使用小顶堆，前k小使用大顶堆。
>边遍历边入堆，当堆的size > k时，pop一下。这样的遍历方式使得当下的堆里始终是目前最大/小的k个值。

```c++
class Solution {
public:
    struct MyCompre {
        // 若用class记得声明为public
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs)const {
            // 小顶堆，其实现是从底向上 层层比较，rhs可以看成较上层
            return lhs.second > rhs.second; 
        }
    };

    vector<int> topKFrequent(vector<int>& nums, int k) {
        int n = nums.size();
        unordered_map<int, int> mp;        

        for (int num : nums) {
            mp[num]++;
        }

        priority_queue<pair<int, int>, vector<pair<int, int>>, MyCompre> que;
        for (const auto& p : mp) {
            que.emplace(p);
            if (que.size() > k) {
                que.pop();
            }
        }

        // 这里按大到小收集答案
        vector<int> res(k);
        for (int i = k - 1; i >= 0; --i) {
            res[i] = que.top().first; que.pop();
        }
        return res;
    }
};
```

- 时间复杂度：`O(nlogk)`，每次入堆`O(logk)`
- 空间复杂度：`O(n)`

### [295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/)

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() `初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

**示例 1：**

```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

**提示:**

- `-105 <= num <= 105`
- 在调用 `findMedian` 之前，数据结构中至少有一个元素
- 最多 `5 * 104` 次调用 `addNum` 和 `findMedian`

> 分析
>
> 要`O(nlogn)`以上。
> 考虑用大根堆`lq`存前半段，小根堆`rq`存后半段，这样两个堆顶就是中间的值。
>
> - addNum时，优先放大根堆`lq`，保证有偶数个数时，两个堆size一样；奇数个时，左边的大根堆`lq`多一个
> - findMedian时，若两个堆size一样，则取两个堆顶出来求平均值，否则，直接返回大根堆`lq`的顶。

```c++
class MedianFinder {
    priority_queue<int> lq; // 大根堆
    priority_queue<int, vector<int>, greater<int>> rq; // 小根堆
public:
    MedianFinder() {

    }
    void addNum(int num) {
        if (lq.size() == rq.size()) { // 元素个数一样：优先放lq  
            if (lq.empty() || num <= rq.top()) {
                lq.push(num);
            } else {
                lq.push(rq.top()); rq.pop();
                rq.push(num);
            }       
        } else { // lq多一个元素: 搞成一样 
            if (num >= lq.top()) {
                rq.push(num);
            } else {
                rq.push(lq.top()); lq.pop();
                lq.push(num);
            }
        }
    }
    double findMedian() {
        if (lq.empty()) return -1e6;

        double ans;
        if (lq.size() == rq.size()) {
            ans = (lq.top() + rq.top()) / 2.0;
        } else {
            ans = lq.top();
        }
        return ans;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

- 时间复杂度：`O(nlogn)`
- 空间复杂度：`O(n)`

## 贪心算法

### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

**提示：**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

>分析
>
>- 确定解空间：算出第`i(0 <= i < n)`天卖出可以获得的最大利润`p[i]`，答案就是`p[i]`中最大值。
>- 算法：遍历`prices`，过程中更新目前的最小值`min_price`，则第i天可以获得的最大利润就是`price[i] - min_price`，同时更新答案。

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min_price = 1000001;
        int ans = 0;

        for (int price : prices) {
            ans = max(ans, price - min_price);
            min_price = min(min_price, price);
        }
        return ans;
    }
};
```

### [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**提示：**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 105`

> 分析
>
> 遍历过程中维护当前可以到达的最远下标`right_most`，若`right_most`能够到达`i`，则更新`right_most`，并判断是否已经可以到达最后下标。

```c++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int right_most = 0;

        for (int i = 0; i < n; ++i) {
            if (i > right_most) break; // 到不了i
            right_most = max(nums[i] + i, right_most);
            if (right_most >= n - 1) return true;
        }
        return false;
    }
};
```

### [45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `nums[n-1]`

>解析
>
>![图片.png](https://pic.leetcode-cn.com/9d5016c6e660a452991185d23b7b4d98853b7c300453d79715b5e9a206085e44-%E5%9B%BE%E7%89%87.png)
>
>贪跳跃时机，只有当上一次跳跃范围不可达`i`时，才会跳。
>
>用`right_most`表示当前可到达的最远下标，`max_jump`表示本次跳跃可以到达的最远下标。当`i == end`并且 `i` 未到达终点时，跳跃次数+1。

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        int right_most = 0; 
        int max_jump = 0; 
        int ans = 0;

        for (int i = 0; i < n - 1; ++i) { // 细节，终点不用跳
            right_most = max(right_most, nums[i] + i);
            
            if (i == max_jump) {
                ans++; // 跳
                max_jump = right_most; // 本次跳远可以到达的最远下标
                if (max_jump >= n - 1) return ans;
            }
        }
        // 跳过了，并且终点不可达 : nums为空或size为1
        return ans > 0 ? -1 : ans; 
    }
}; 
```

### [763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)

给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。

返回一个表示每个字符串片段的长度的列表。

**示例 1：**

```
输入：s = "ababcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
```

**提示：**

- `1 <= s.length <= 500`
- `s` 仅由小写英文字母组成

> 解析
>
> 1. 第一次遍历，用一个数组`rightmost[26]`记录26个字母最后一次出现的下标。
> 2. 第二次遍历，记录当前遍历过字母可达的最远下标`max_pos`，若`i == max_pos`，则划分出新的一段`[last_pos + 1, i]`，并更新：`last_pos = max_pos`

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        int n = s.size();
        int rightmost[26];
        memset(rightmost, 0, sizeof rightmost);

        for (int i = 0; i < n; ++i) {
            rightmost[s[i] - 'a'] = i;
        }

        vector<int> res;
        int last_pos = -1;
        int max_pos = 0;
        for (int i = 0; i < n; ++i) {
            max_pos = max(max_pos, rightmost[s[i] - 'a']);
            if (i == max_pos) {
                res.push_back(i - last_pos);
                last_pos = max_pos;
            }
        }

        if (max_pos >= n) res.push_back(n - 1 - last_pos); // 最后一段
        return res;
    }
};
```

## 动态规划

1. 不好想的动规可以尝试记忆化搜索，从选与不选的角度入手；
2. 动规关键在于给出恰当的状态定义。

> 什么是记忆化搜索？
> —— 一种递归，从后往前的，不同分支之间会存在重合路径的。所以使用一个缓存数组记录到过的结点，使得递归过程中每个结点只会处理一次，并且不再往下递归，不再是指数级的递归。
>
> - 优势：1. 实现更简单快捷；2. 边界处理方便，无异于平时写递归出口
> - 劣势：1. 缓存和递归栈废空间，少数情况下会被卡； 2. 少数题实现起来反而复杂； 3. 可能“卡常”

### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**提示：**

- `1 <= n <= 45`

> 分析
>
> 1. 状态定义：`f[n + 1]`：`f[i]`表示爬了n阶的方案数；
> 2. 递推式：`f[i] = f[i - 2] + f[i - 1]`;
> 3. 定义边界：`f[0] = f[1] = 1`，`f[0]`按照本题情况给的1，

法一：一维线性dp

```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> f(n + 1);
        f[0] = f[1] = 1;
        for (int i = 2; i <= n; ++i) {
            f[i] = f[i - 1] + f[i - 2];
        }
        return f[n];
    }
};
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

法二：一维线性dp空间优化。只与前两个状态有关，并且只需保留最新值，故用两个变量滚动即可。

```c++
class Solution {
public:
    int climbStairs(int n) {
        int p = 0, q = 1, res = 0; // res = p + q;
        for (int i = 1; i <= n; ++i) { 
            res = p + q;
            p = q;
            q = res;
        }
        return res;
    }
};
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

### [118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**提示:**

- `1 <= numRows <= 30`

> 分析
>
> 1. 状态定义：`f[n + 1][n + 1]`，`f[i][j]`表示第`i`行第`j`列的值
> 2. 递推式：`f[i][j] = f[i - 1][j - 1] + f[i - 1][j]`
> 3. 定义边界：`f[0][0...n]` = 0
>
> 实现时作参考即可

```c++
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> res;

        for (int i = 1; i <= numRows; ++i) { // 第i行
            vector<int> row(i, 1);
            for (int j = 1; j < i - 1; ++j) { // 两端就是1
                if (!res.empty()) {
                    row[j] = res.back()[j - 1] + res.back()[j]; 
                }
            }
            res.emplace_back(row);
        }
        return res;
    }
};
```

- 时间复杂度：`O(n^2)`
- 空间复杂度：`O(1)?`所用空间装要返回的结果，不算额外空间

### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

> 分析
>
> 1. 状态定义：`f[n][2]`，
>
>    - `f[i][0]`表示i间房屋中，没偷第i间房屋情况下，可以偷窃到的最大金额
>    - `f[i][1]`表示i间房屋中，偷了第i间房屋情况下，可以偷窃到的最大金额
>
> 2. 递推式：
>
>    显然，房屋增多，偷窃金额可能会增多，但必不会减少，故`f[i]`只要考虑`f[i - 1]`即可
>
>    - `f[i][0] = max(f[i - 1][1], f[i - 1][0])`
>    - `f[i][1] = f[i - 1][0] + nums[i]`
>
> 3. 定义边界：`f[0][0] = 0, f[0][1] = nums[0]`

法一：线性dp

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;

        int n = nums.size();
        vector<vector<int>> f(n, vector<int>(2));
        f[0][1] = nums[0];
        for (int i = 1; i < n; ++i) {
            f[i][0] = max(f[i - 1][0], f[i - 1][1]);
            f[i][1] = f[i - 1][0] + nums[i];
        }
        return max(f[n - 1][0], f[n - 1][1]);
    }
};
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(n)`

法二：线性dp空间优化，只与`f[i - 1][0], f[i - 1][1]`有关，用两个变量滚动即可

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.empty()) return 0;

        int n = nums.size();
        // p: f[i][0], q:f[i][1]
        int p = 0, q = nums[0];
        for (int i = 1; i < n; ++i) {
            // p = max(p, q);
            // q = p + nums[i]; 这里的p已经不是上个状态的p了
            int temp_p = p; // 保存一下上个状态的p
            p = max(p, q);
            q = temp_p + nums[i];
        }
        return max(p, q);
    }
};
```

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`

法三：[记忆化搜索](https://leetcode.cn/link/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1Xj411K7oF%2F)，按照**选与不选**来决定递归路径，并且缓存已经到过的结点

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> memo(n, -1); // -1不在有效值范围内
        auto dfs = [&](auto&& self, int i)->int {
            if (i < 0) return 0;

            int &res = memo[i];
            if (res != -1) return res;
            return res = max(self(self, i - 2) + nums[i], 
                             self(self, i - 1));
        };
        return dfs(dfs, n - 1); // 从最后一间房子开始往回推
    }
};
```

- 时间复杂度：`O(n)`，子问题数量(n) × 子问题复杂度(一次max)
- 空间复杂度：`O(n)`

### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**提示：**

- `1 <= n <= 104`

> 分析
>
> **[完全背包问题](https://www.acwing.com/problem/content/description/3/)**：有 N种物品和一个容量是 V的背包，每种物品都有无限件可用。
> 第 i 种物品的体积是 vi，价值是 wi。
> 求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
>
> 1. - 状态定义: `f[i][j]`表示选择前 i 种，体积不超过 j 的最大价值
>    
>    - 二维递推式推导：`f[i][j] = max( f[i - 1][j], f[i - 1][j - vi] + wi, f[i - 1][j - vi * 2] + wi * 2, ... )`，
>      	 由于`f[i][j - vi] + wi = max( f[i - 1][j - vi] + wi, f[i - 1][j - vi * 2] + wi * 2, ... )`，代入上式
>      	
>      	可得 `f[i][j] = max( f[i - 1][j], f[i][j - vi] + wi )`(ps：式1表示选了0、1、2、3... 个物品 i )；
>      	
>    - 一维递推式：`f[j] = max(f[j], f[j - v[i]] + w[i])`。
>    
> 2. 模板代码
>
> ```c++
> // 无空间优化
> const int N = 1010;
> int f[N][N]; 
> int w[N], v[N]; 
> 
> int main() {
> 	int n, m;
> 	cin >> n >> m;
> 	for (int i = 1; i <= n; ++i) cin >> v[i] >> w[i];
> 	// f[i][j]表示选择前i种，体积不超过j的最大价值
> 	// f[i][j] = max(f[i - 1][j], f[i][j - v]);
> 	for (int i = 1; i <= n; i ++) {
> 		for (int j = 1; j <= m; j ++) {
> 			f[i][j] = f[i - 1][j]; // f[i - 1][j]是一定存在的
> 			if (j >= v[i]) {
> 				f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);
> 			}
> 		}
> 	}
> 	cout << f[n][m] << endl;
> 	return 0;
> }
> 
> // 空间优化
> const int N = 1010;
> int f[N]; 
> int w[N], v[N]; 
> 
> int main() {
> 	int n, m;
> 	cin >> n >> m;
> 	for (int i = 1; i <= n; ++i) cin >> v[i] >> w[i];
> 	for (int i = 1; i <= n; i ++) {
> 		for (int j = v[i]; j <= m; j ++) {
> 			f[j] = max(f[j], f[j - v[i]] + w[i]);
> 		}
> 	}
> 	cout << f[m] << endl;
> 	return 0;
> }
> ```
>
> 
>
> 法一：完全背包变种
>
> ​	这里N = sqrt(n)， 容量V = n，每件物品 i 的体积是 i * i，价值都是1。
> ​	求解哪些物品装入背包，使得这些物品的总体积刚好**等于**背包容量，且总价值**最小**。
>
> - 递推式：`f[i][j] = min( f[i - 1][j], f[i][j - i * i] + 1)`
>
> 二维实现
>
> ```c++
> class Solution {
> public:
>     int numSquares(int n) {
>         // f[i][j] = min(f[i - 1][j], f[i][j - i * i] + 1);
>         int N = sqrt(n);
>         int V = n;
>         vector<vector<int>> f(N + 1, vector<int>(V + 1, n));
>         // 边界处理: f[][0] = 0
>         for (int i = 0; i <= N; ++i) f[i][0] = 0;
> 
>         for (int i = 1; i <= N; ++i) {
>             int v = i * i;
>             for (int j = 1; j <= V; ++j) {
>                 f[i][j] = f[i - 1][j];
>                 if (j >= v) {
>                     f[i][j] = min(f[i][j], f[i][j - v] + 1);
>                 }
>             }
>         }
>         return f[N][V];
>     }
> };
> ```
>
> - 时间复杂度：`O(NV)`，N是物品数量，V是背包容量
> - 空间复杂度：`O(NV)`
>
> 一维实现
>
> 当前状态只与上一层相关，
>
> ```c++
> class Solution {
> public:
>     int numSquares(int n) {
>         // f[i][j] = min(f[i - 1][j], f[i][j - i * i] + 1);
>         int N = sqrt(n);
>         int V = n;
>         vector<int> f(V + 1, n + 1); // 初始化为最大值
>         f[0] = 0; // j为0是边界
>         for (int i = 1; i <= N; ++i) {
>             int v = i * i;
>             for (int j = v; j <= V; ++j) {
>                 f[j] = min(f[j], f[j - v] + 1);
>             }
>         }
> 
>         return f[V];
>     }
> };
> ```
>
> - 时间复杂度：`O(NV)`，N是物品数量，V是背包容量
> - 空间复杂度：`O(V)`
>
> 法二：[记忆化搜索](https://leetcode.cn/problems/perfect-squares/solutions/2830762/dong-tai-gui-hua-cong-ji-yi-hua-sou-suo-3kz1g)
> 1. 定义 dfs(i,j) 表示从前 i 个完全平方数中选一些数（可以重复选），满足元素和恰好等于 j，最少要选的数字个数。
>     考虑第 i 个完全平方数 i^2 选或不选，然后取最小值：
>
>   `dfs(i, j) = min( dfs(i - 1, j), dfs(i, j - i * i) + 1 )`
>
> 2. 递归边界：
>    - 正常结束：j == 0；
>    - 异常结束：
>       - j < 0，用了过大的数
>       - i == 0，i 是从正数往下走的，走到0表示枚举完了（ps：怎么理解更好）。
>
> 
>
> ``` c++
> class Solution {
> public:
>     int numSquares(int n) {
>         if (n <= 0) return 0;
> 
>         int m = sqrt(n);
>         vector<vector<int>> memo(m + 1, vector<int>(n + 1, -1));
>         auto dfs = [&](auto&& self, int i, int j)->int {
>             if (j == 0) return 0; // 正常结束
>             if (j < 0 || i == 0) return 10001; // 异常结束
> 
>             int &res = memo[i][j];
>             if (res != -1) return res;
>             return res = min(self(self, i - 1, j), self(self, i, j - i * i) + 1);
>         };
>         return dfs(dfs, m, n); 
>     }
> };
> ```
>
> - 时间复杂度：`O(n·sqrt(n))`
> - 空间复杂度: `O(n·sqrt(n))`
